---
title: "[Spring] Spring Data JPA에서 새로운 Entity인지 판단하는 방법"
date: 2025-10-20 19:51:59 +0900
categories: [Spring, 매일메일]
tags: [TIL, Spring]
---

# Spring Data JPA에서 새로운 Entity인지 판단하는 방법
## 핵심: 새로운 Entity 파악이 틀리면, 불필요한 조회가 일어나 비효율적!

[`SimpleJpaRepository#save`]

```java
// org.springframework.data.jpa.repository.support.SimpleJpaRepository;

@Transactional
public <S extends T> S save(S entity) {
    Assert.notNull(entity, "Entity must not be null");
    if (this.entityInformation.isNew(entity)) {
        this.entityManager.persist(entity);
        return entity;
    } else {
        return this.entityManager.merge(entity);
    }
}
```

- Entity 저장 시, JpaEntityInformation의 `isNew(T entity)` 로 신규 여부 확인

---

[`JpaEntityInformation$isNew`]

1) [`JpaMetamodelEntityInformation#isNew`]

  ```java
  // org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation
  @Override
  public boolean isNew(T entity) {
  
      // 1) @Version 필드가 없거나, primitive 타입이면 → 부모 로직으로(ID 기반)
      if (versionAttribute.isEmpty()
          || versionAttribute.map(Attribute::getJavaType).map(Class::isPrimitive).orElse(false)) {
          return super.isNew(entity); // AbstractEntityInformation#isNew
      }
  
      // 2) @Version 필드가 "래퍼 타입"이면 → null 여부로 신규 판단
      BeanWrapper wrapper = new DirectFieldAccessFallbackBeanWrapper(entity);
  
      return versionAttribute
              .map(it -> wrapper.getPropertyValue(it.getName()) == null)
              .orElse(true);
  }
  ```
  
  - `@Version` 필드가 있고, 그 타입이  Wrapper Type(ex: `Long`) → 버전 값이 `null` 이면 신규
    - 그 외, `AbstractEntityInformation#isNew` 호출

2) [`AbstractEntityInformation#isNew`]

```java
// org.springframework.data.repository.core.support.AbstractEntityInformation

public boolean isNew(T entity) {

    Id id = getId(entity);
    Class<ID> idType = getIdType();

    if (!idType.isPrimitive()) {
        return id == null;
    }

    if (id instanceof Number) {
        return ((Number) id).longValue() == 0L;
    }

    throw new IllegalArgumentException(String.format("Unsupported primitive id type %s", idType));
}
```

- `@Id` 어노테이션 사용 필드 (ID 타입)로 신규 여부 판단
  - Id가 `primitive` 이 아니면? null 여부 확인 (`id == null` 이면 신규)
  - Id가 `Number` primitive 라면? 0인지 여부 확인 (`longValue() == 0L` 이면 신규)
  - 그 외 primitive? 지원 안함(예외)

3) [`JpaPersistableEntityInformation#isNew`]

```java
// org.springframework.data.jpa.repository.support.JpaPersistableEntityInformation

public class JpaPersistableEntityInformation<T extends Persistable<ID>, ID> 
        extends JpaMetamodelEntityInformation<T, ID> {

    public JpaPersistableEntityInformation(Class<T> domainClass, Metamodel metamodel, 
            PersistenceUnitUtil persistenceUnitUtil) {
        super(domainClass, metamodel, persistenceUnitUtil);
    }

    @Override
    public boolean isNew(T entity) {
        return entity.isNew();
    }

    @Nullable
    @Override
    public ID getId(T entity) {
        return entity.getId();
    }
}
```

- 도메인 엔티티가 `Persistable`을 구현하면, 엔티티가 직접 `isNew()` 결정

---

### `@GeneratedValue` 어노테이션으로 키 생성 전략 사용하면?

- **키 생성 전략(IDENTITY, SEQUENCE, AUTO 등)**을 사용하면, **DB 저장 시점에 ID가 자동 할당**

  ⇒ 저장 전 메모리 상태에서는 `id == null` → `isNew() == true` → 새로운 Entity → `persist()`


### 직접 ID를 할당하는 경우에는?

- 엔티티 생성 시 이미 ID가 존재하므로 `id != null` → `isNew() == false` → `merge()`

  ⇒ 실제로는 신규 엔티티인데도 DB 조회 + merge 복사 잡업이 수행되어 비효율

- 엔티티에서 `Persistable<T>` 인터페이스를 구현해 `isNew()`를 직접 정의하여, `JpaPersistableEntityInformation`가 정확히 신규 여부를 판단하도록 해야 함

---

### 새로운 Entity인지 판단하는 게 왜 중요할까?

```java
// org.springframework.data.jpa.repository.support.SimpleJpaRepository;

@Transactional
public <S extends T> S save(S entity) {
    Assert.notNull(entity, "Entity must not be null");
    if (this.entityInformation.isNew(entity)) {
        this.entityManager.persist(entity);
        return entity;
    } else {
        return this.entityManager.merge(entity);
    }
}
```

- `persist()`
  - INSERT 전용
  - 영속 컨텍스트에 새 엔티티 등록
  - 불필요한 **SELECT** ❌
- `merge()`
  - 준영속/Detached 객체를 현재 영속 컨텍스트에 복사
  - 내부적으로 DB 조회(SELECT)가 선행될 수 있음
  - 신규 엔티티에 쓰면 비효율 + 의도 혼동 → 성능/의도 모두 손해

---

### 정리표

| 상황 | isNew 판단 기준 | 결과 |
| --- | --- | --- |
| `@Version` **래퍼 타입**(`Long`/`Integer` 등) 존재 | **버전 값이 `null`** → 신규 | `persist` |
| `@Version` **없음** or **primitive 타입** | **ID 기반 판단**으로 위임 | 아래 행 참조 |
| ID 타입이 **래퍼/참조 타입** | **ID == null** → 신규 | `persist` |
| ID 타입이 **primitive 숫자** | **ID == 0** → 신규 | `persist` |
| **직접 ID 할당(Assigned)** + `@GeneratedValue` 미사용 | **ID가 채워짐 → 신규 아님으로 판단될 위험** | 기본에선 `merge` (비효율 가능) → **`Persistable`로 교정 권장** |
| `Persistable` 구현 | **엔티티의 `isNew()` 리턴값** | 리턴값에 따라 `persist`/`merge` |

---

참고: [maeil-mail 매일메일 - Spring Data JPA에서 새로운 Entity인지 판단하는 방법은 무엇일까요?](https://www.maeil-mail.kr/question/27)
