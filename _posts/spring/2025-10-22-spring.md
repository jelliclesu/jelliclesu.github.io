---
title: "[Spring] EntityManager (엔티티 매니저)"
date: 2025-10-22 19:14:17 +0900
categories: [Spring, 매일메일]
tags: [TIL, Spring]
---
### 정의

> JPA에서 영속성 컨텍스트(Persistence Context) 를 관리하는 핵심 인터페이스
> 
> 즉, **엔티티를 영속성 컨텍스트에 등록.조회.수정.삭제하는 창구** 역할


- 하나의 EntityManager 는 하나의 영속성 컨텍스트를 관리

---

#### **❓영속성 컨텍스트(Persistence Context)란?**

> 엔티티를 영구 저장하는 환경

- 애플리케이션과 데이터베이스 사이에서 엔티티를 1차 캐시로 관리
- DB 접근을 최소화하고, 객체 중심의 CRUD를 가능하게 함

주요 기능

- **1차 캐시**: 동일한 엔티티를 여러 번 조회해도 DB에 재요청하지 않고 캐시에서 반환
- **쓰기 지연(Transactional Write-Behind)**: `persist()` 시 즉시 INSERT하지 않고, 트랜잭션 커밋 시점에 한꺼번에 SQL 실행
- **변경 감지(Dirty Checking)**: 영속 상태의 엔티티 필드 변경을 감지해 자동으로 UPDATE SQL 생성
- **지연 로딩(Lazy Loading)**: 연관된 엔티티를 실제 사용할 때 쿼리 실행

---

### 엔티티 상태

| 상태 | 설명 | 전이 메서드 |
| --- | --- | --- |
| **비영속 (Transient)** | 새로 생성된 객체로, 아직 영속성 컨텍스트에 저장되지 않은 상태 | `new Member()` |
| **영속 (Persistent)** | 엔티티가 영속성 컨텍스트에 저장되어 관리되는 상태 | `em.persist(entity)` |
| **준영속 (Detached)** | 한 번 영속되었다가 컨텍스트에서 분리된 상태 | `em.detach()`, `em.clear()`, `em.close()` |
| **삭제 (Removed)** | 삭제 예약된 상태, 커밋 시 DB에서 삭제 | `em.remove(entity)` |

---

### EntityManager 주요 역할

`persist(entity)`:  엔티티 등록

- 엔티티를 영속성 컨텍스트에 저장하고, DB에 INSERT 준비

`find(Entity.class, id)`: 엔티티 조회

- 1차 캐시 → DB 순으로 조회

`merge(detachedEntity)`: 엔티티 병합

- 준영속 상태의 엔티티를 다시 영속 상태로 변경

`remove(entity)`: 엔티티 삭제

- 영속성 컨텍스트에서 제거, 트랜잭션 커밋 시 DELETE 실행

`flush()`: 플러시

- 쓰기 지연 SQL을 즉시 DB에 반영

`clear()`, `close()`: 영속성 컨텍스트 초기화/종료

- 관리 중인 엔티티 제거 및 컨텍스트 종료

`createQuery()`, `createNativeQuery()`: JPQL/Native Query 실행

- SQL 직접 실행 가능

---

### 상태 전이 예시 코드

```java
@Entity
public class Member {
    @Id @GeneratedValue
    private Long id;
    private String name;

    public Member(String name) {
        this.name = name;
    }
}

// 엔티티 매니저 사용 예시
EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();

tx.begin();

// 1️⃣ 비영속 상태
Member member = new Member("산초");

// 2️⃣ 영속 상태로 전환
em.persist(member); // INSERT SQL은 아직 DB에 실행되지 않음 (쓰기 지연)

// 3️⃣ 변경 감지 (Dirty Checking)
member.setName("라쉬포드"); // 트랜잭션 커밋 시 UPDATE SQL 자동 생성

// 4️⃣ 준영속 상태 전환
em.detach(member); // 이제 변경 사항은 더 이상 반영되지 않음

// 5️⃣ 삭제 상태
em.remove(member); // DELETE 예약

tx.commit(); // INSERT/UPDATE/DELETE SQL이 실제 DB 반영
em.close();

```

---

### Spring Data JPA에서는?

```java
// org.springframework.data.jpa.repository.support.SimpleJpaRepository

public class SimpleJpaRepository<T, ID> implements JpaRepository<T, ID> {

    private final EntityManager entityManager;
    private final JpaEntityInformation<T, ?> entityInformation;

    public SimpleJpaRepository(JpaEntityInformation<T, ?> entityInformation, EntityManager em) {
        this.entityInformation = entityInformation;
        this.entityManager = em;
    }
}

...

@Transactional
public <S extends T> S save(S entity) {
    Assert.notNull(entity, "Entity must not be null");

    if (entityInformation.isNew(entity)) {
        // 신규 엔티티
        entityManager.persist(entity);  // 영속성 컨텍스트에 등록
        return entity;
    } else {
        // 이미 존재하는 엔티티
        return entityManager.merge(entity);  // 병합하여 영속 상태로 전환
    }
}
```

- `EntityManager`를 직접 쓰지 않지만, `JpaRepository`는 `SimpleJpaRepository`를 통해 내부적으로 사용

→ 즉, `save()`, `findById()` 같은 메서드들은 결국 `em.persist()`, `em.find()`로 구현되어 있음

- 엔티티 매니저의 동작 원리를 알아야, 영속성 전이, 캐싱, flush 타이밍 등의 문제를 디버깅 할 수 있음!

---

참고: [maeil-mail 매일메일 - 엔티티 매니저에 대해 설명해주세요.](https://www.maeil-mail.kr/question/29)
