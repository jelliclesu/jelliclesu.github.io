---
title: "[CS] 프로그래밍 패러다임: 객체지향 프로그래밍 (SOLID 원칙)"
date: 2025-04-23 11:55:15 +0900
categories: [CS, 프로그래밍 패러다임]
tags: [TIL, CS]
---
# CS
## 📚 1.2 프로그래밍 패러다임

### 1.2.2 객체지향 프로그래밍 (SOLID 원칙)

#### 📘 정의
- 객체지향 설계의 5가지 핵심 원칙으로, 유지보수성과 확장성이 높은 시스템 설계를 위해 필요한 가이드라인
   
1. 단일 책임 원칙 (**S**RP: **S**ingle **R**esponsibility **P**rinciple) - 클래스는 **단 하나의 책임**만 가져야 한다.
2. 개방-폐쇄 원칙 (**O**CP: **O**pen-**C**losed **P**rinciple) - **확장에는 열려 있고, 수정에는 닫혀** 있어야 한다.
3. 리스코프 치환 원칙 (**L**SP: **L**iskov **S**ubstitution **P**rinciple) - 자식 클래스는 **부모 클래스의 역할을 대체**할 수 있어야 한다.
4. 인터페이스 분리 원칙 (**I**SP: **I**nterface **S**egregation **P**rinciple) - 하나의 큰 인터페이스보단 **작고 명확한 인터페이스를 여러 개**로 나누자.
5. 의존 역전 원칙 (**D**IP: **D**ependency **I**nversion **P**rinciple) - **고수준 모듈**은 저수준 모듈에 의존하지 않고, **추상화에 의존**하라

---

#### 📌 예시 상황
1. **SRP** - 컨트롤러가 비즈니스 로직까지 다 가지면 X ➔ 서비스 분리
2. **OCP** - 새로운 결제 수단 추가 시, 기존 코드를 변경하지 않고 확장 가능해야 함
3. **LSP** - `Bird` 를 상속받은 `Penguin` 이 `fly()` 를 호출하면 오류! ➔ LSP 위반
4. **ISP** - `UserInterface` 에 `sendEmail()` 도 같이 있으면 불필요한 구현 강요하는 것
5. **DIP** - 서비스가 구체 클래스가 아닌 인터페이스에 의존해야 유연한 구조

---

#### 🎯 사용 이유 / 장점
1. **SRP** - 책임이 분명하여 **이해도 향상**, **테스트 용이**
2. **OCP** - 코드 변경 없이 기능 추가 가능하여 **오류 위험이 적음**
3. **LSP** - **대체 가능성이 보장**되어 상속 의미가 유지됨
4. **ISP** - 인터페이스 단위로 구현하여 **불필요한 의존 제거**
5. **DIP** - 추상화 중심 구조로 **유연한 설계**와 **테스트 용이** (Mock 가능)

---

#### ⚠️ 단점
1. **SRP** - 너무 쪼개면 과도한 클래스 수로 오히려 복잡해질 수 있음
2. **OCP** - 추상화만으로 모든 기능 확장이 어려울 수 있음
3. **LSP** - 모든 상속이 적절한 치환을 보장하진 않음 (무리한 상속 주의)
4. **ISP** - 너무 잘게 나누면 인터페이스 관리가 어려움
5. **DIP** - DI 컨테이너(Spring 등에서)의 개념 이해 필요

---

#### 🏢 실무 사용 여부
- Spring/Spring Boot 구조 자체가 SOLID 원칙 기반
  - Spring DI = DIP 구현
  - Controller-Service 분리 = SRP 적용
  - Interface 기반 전략 선택 = OCP + ISP + LSP 조합
  - 테스트 코드 작성 시 Mock 객체 사용 ➔ DIP 필요

---

#### 💻 Java/Spring 예시

[SRP]

```java
// 나쁜 예: 하나의 클래스가 모든 역할
public class UserManager {
    public void createUser() { }
    public void validateUser() { }
    public void sendWelcomeEmail() { }
}

// 좋은 예: 책임 분리
public class UserService { public void createUser() { } }
public class EmailService { public void sendWelcomeEmail() { } }

```

[OCP]

```java
// 기존 PaymentService 를 변경하지 않고 새로운 결제 방식 추가
public interface Payment {
  void pay();
}

public class CardPayment implements Payment { public void pay() { ... } }
public class KakaoPay implements Payment { public void pay() { ... } }

public class PaymentProcessor {
  private final Payment payment;
  public PaymentProcessor(Payment payment) {
    this.payment = payment;
  }
  public void process() {
    payment.pay(); // 확장에는 열려 있고, 기존 코드는 수정 없음
  }
}
```

[LSP]

```java
class Bird {
  void fly() { ... }
}

class Penguin extends Bird {
  @Override
  void fly() {
    throw new UnsupportedOperationException("펭귄은 못 날아요");
  }
}
// LSP 위반: Penguin 은 Bird 를 대체할 수 없음

```

[ISP]

```java
public interface MultiFunctionDevice {
  void print();
  void scan();
  void fax();
}

// → ISP 적용
public interface Printer { void print(); }
public interface Scanner { void scan(); }

```

[DIP]

```java
// 나쁜 예: 직접 구현체에 의존
public class OrderService {
    private final MySQLOrderRepository repo = new MySQLOrderRepository(); // DIP 위반
}

// 좋은 예: 추상화에 의존
public class OrderService {
    private final OrderRepository repo;
    public OrderService(OrderRepository repo) {
        this.repo = repo;
    }
}

```

---

#### 🎤 면접 예상 질문
1. SOLID 원칙이란?
   - 객체지향 설계의 5가지 핵심 원칙으로, 유지보수와 확장성, 테스트 용이성을 높이는 구조 설계 가이드입니다.
2. 실무에서 SOLID 는 어떻게 활용되나요?
   - Spring 프레임워크 구조 자체가 SOLID 원칙을 따릅니다.
   - DI 는 DIP, Controller-Service 분리는 SRP, 전략 패턴이나 인터페이스 설계는 OCP/ISP 를 반영하며,
   - 적절한 상속 구조는 LSP 를 충족시킵니다.
3. OCP 와 DIP 에 차이는 무엇인가요?
   - 둘 다 유연성을 위한 설계 원칙이지만,
   - OCP 는 기능 확장을 위한 구조 설계 원칙이고,
   - DIP 는 추상화에 의존함으로써 구현체 변경에 유연한 구조를 만들자는 원칙입니다.
