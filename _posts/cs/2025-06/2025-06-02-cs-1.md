---
title: "[CS] 복잡도: 시간 복잡도 (Time Complexity)"
date: 2025-06-02 11:32:15 +0900
categories: [CS, 자료구조]
tags: [TIL, CS, 복잡도]
---
# CS 5장 자료구조
## 📚 5.1 복잡도 (Complexity)
> 알고리즘이 실행되는데 필요한 **시간 또는 메모리 자원의 양을 수치화**한 것
> 자료구조 선택이나 쿼리 작성에서 **성능을 예측하고 최적화**하는데 매우 중요

### 5.1.1 시간 복잡도 (Time Complexity)

#### 📘 정의 
- 입력 크기(n)가 커질 때, 실행 시간이 **얼마나 증가하는지를 수치화**한 것
- **빅오 표기법(Big-O)**으로 나타냄

---

#### 📌 주요 표기법

| 표기법          | 설명                 | 예시                    |
| ------------ | ------------------ | --------------------- |
| O(1)         | 상수 시간 – 입력 크기와 무관  | 배열 인덱스 접근, 해시맵에서 키 조회 |
| O(log n)     | 로그 시간 – 절반씩 나눠서 찾음 | 이진 탐색, B+ 트리 인덱스      |
| O(n)         | 선형 시간 – 전체 순회      | 리스트 탐색, 전체 테이블 조회     |
| O(n log n)   | 로그 정렬 + 반복         | 병합 정렬, 퀵 정렬           |
| O(n²)        | 중첩 반복 – 행렬 비교      | 버블 정렬, 중첩 루프 조인       |
| O(2ⁿ), O(n!) | 지수/팩토리얼 – 매우 느림    | 백트래킹, 완전탐색            |


---

#### 🎯 사용 이유

- 대량의 데이터에 대한 처리 속도 예측 가능
- 자료구조나 알고리즘 선택의 기준이 됨
- 코드가 정확하더라도 성능이 나쁘면 실수에서 사용 불가

---

#### 🏢 실무 중요 포인트

| 상황        | 권장 복잡도             | 
|-----------|--------------------|
| 자주 탐색해야 함 | O(1), O(log n)     |
| 삽입/삭제 잦음  | O(1), O(log n)     |
| 정렬 필요     | O(n log n) 이상은 피하기 |


---

#### 💻 자료구조에서의 시간 복잡도

< 주요 연산 기준 >
- **탐색 (Search)**: 특정 값을 찾는 데 걸리는 시간
- **삽입 (Insert)**: 값을 추가할 때 걸리는 시간
- **삭제 (Delete)**: 값을 제거하는 데 걸리는 시간

| 자료구조                 | 탐색                            | 삽입             | 삭제             | 비고                    |
|----------------------|-------------------------------|----------------|----------------|-----------------------|
| 배열 (Array)           | O(1) (인덱스) <br/> O(n) (값)     | O(n) (중간 삽입 시) | O(n) (중간 삭제 시) | 인덱스 접근은 빠름            |
| 연결 리스트 (Linked List) | O(n)                          | O(1) (앞쪽 삽입 시) | O(1) (앞쪽 삭제 시) | 랜덤 접근 불가              |
| 스택 (Stack)           | O(n)                          | O(1)           | O(1)           | LIFO 구조               |
| 큐 (Queue)            | O(n)                          | O(1)           | O(1)           | FIFO 구조               |
| 해시 테이블 (Hash Table)  | O(1) (평균) <br/> O(n) (최악)     | O(1)           | O(1)           | 충돌 시 성능 저하            |
| 이진 탐색 트리 (BST)       | O(log n) (평균) <br/> O(n) (최악) | O (log n)      | O (log n)      | 균형 유지 필요              |
| 힙 (Heap)             | O(n)                          | O(log n)       | O(log n)       | 탐색은 느림<br/> 우선순위 큐 용도 |
| 트라이 (Trie)           | O(k) (k = 문자열 길이)             | O(k)           | O(k)           | 문자열 검색에 최적            |


- **배열 vs 연결 리스트**
  - 배열은 인덱스로 빠르게 접근 가능하지만, 중간 삽입/삭제는 느림
  - 연결 리스트는 중간 접근은 느리지만, 삽입/삭제는 빠름
- **해시 테이블**
  - 평균 O(1) 이지만, 충돌이 많거나 해시 분포가 나쁘면 O(n)  
- **힙**
  - 가장 큰/작은 값을 빠르게 꺼내는 데 유리 (우선순위 큐에서 사용)
- **트라이**
  - 문자열 검색, 자동완성 등에 특화됨 (접두사 검색 빠름)

---

#### 🎤 면접 예상 질문
1. 시간 복잡도란 무엇인가요?
   - 입력 크기에 따라 알고리즘의 실행 시간을 수치화한 것입니다. 주로 빅오 표기법을 사용합니다.
2. 이진 탐색이 O(log n)인 이유는?
   - 검색 범위를 매 단계 절반씩 줄이기 때문에, 데이터가 n 개 있을 때 약 log n 번만 비교하면 원하는 값을 찾을 수 있습니다.
   - 예를 들어 1024 개 데이터라면 10번만 비교하면 됩니다.
3. 해시맵 탐색이 O(1)인 이유는?
   - 키를 해시 함수로 변환하여 배열 익덱스로 바로 접근하기 때문에 평균적으로 O(1)의 탐색이 가능하고,
   - 충돌이 많거나 해시 함수가 좋지 않으면 O(n)의 최악의 경우도 발생할 수 있습니다.
4. 배열과 연결 리스트의 시간 복잡도 차이는?
   - 배열은 인덱스 기반의 빠른 접근으로 O(1)의 시간 복잡도를 가지지만,
   - 중간에 값을 삽입하거나 삭제할 경우 O(n) 시간이 걸립니다.
   - 연결 리스트는 앞쪽 삽입/삭제는 O(1)의 시간 복잡도로 빠르지만,
   - 원하는 위치를 찾기 위한 탐색이 O(n)으로 느립니다.
5. 정렬된 데이터 검색에 적합한 자료구조는?
   - 이진 탐색 트리 혹은 배열이 적합합니다.
   - 특히 이진 탐색 트리는 O(log n)으로 효율적인 탐색이 가능하고,
   - 배열은 이진 탐색이 가능한 상태라면 정렬 + O(log n) 탐색이 가능합니다.
