---
title: "[CS] CPU 스케줄링 알고리즘: 선점형 스케줄링 (Preemptive Scheduling)"
date: 2025-05-23 12:33:24 +0900
categories: [CS, CPU 스케줄링 알고리즘]
tags: [TIL, CS]
---
# CS
## 📚 3.4 CPU 스케줄링 알고리즘

### 3.4.2 선점형 스케줄링 (Preemptive Scheduling)

#### 📘 정의
- 운영체제가 실행 중인 프로세스의 CPU 사용을 강제로 중단하고, 다른 프로세스에 CPU 를 넘길 수 있는 방식

⭐️ 선점 발생 상황
- 시간 초과
- 더 높은 우선순위 도착
- I/O 완료 등으로 대기 중 프로세스 복귀

---

#### 📌 대표 알고리즘
##### 1. **Round Robin** (RR)
> 모든 프로세스에게 동일한 시간 할당량 (Time Quantum) 부여

- 장점: 공정성, 빠른 응답성
- 단점: Context Switching 비용 높음

[예시]

```plaintext
Time Quantum = 4ms
프로세스: P1(10), P2(4), P3(5)
실행 순서: P1(4) ➔ P2(4) ➔ P3(4) ➔ P1(4) ➔ P3(1) ➔ P1(2)

[0~4]     P1(4) 실행 
[4]       P1 ➔ P2 교체
[4~8]     P2(4) 실행
[8]       P2 종료 ➔ P3 교체
[8~12]    P3(4) 실행
[12]      P3 ➔ P1 교체
[12~16]   P1(4) 실행
[16]      P1 ➔ P3 교체
[17]      P3 종료 ➔ P1 교체
[17~19]   P1(2) 실행
[19]      P1 종료
  
대기 시간 = 종료 - 도착 - 실행
P1 = 19 - 0 - 10 = 9
P2 = 8 - 0 - 4 = 4
P3 = 17 - 0 - 5 = 12

평균 대기 시간: (9 + 4 + 12)/3 = 8.33
```

--

##### 2. **SRTF** (Shortest Remaining Time First)
> 남은 실행 시간이 가장 짧은 프로세스 먼저 실행 (SJF 의 선점 버전)

- 장점: 평균 대기 시간 최소화
- 단점: 실행 시간 예측 필요, 기아 가능성

[예시]

```plaintext
프로세스 도착 시간 및 실행 시간: P1(0, 8), P2(1, 4), P3(2, 2), P4(3, 1)

실행 순서: P1(1) ➔ P2(1) ➔ P3(1) ➔ P3(1) ➔ P4(1) ➔ P2(3) ➔ P1(7)

[0]      P1 시작
[1]      P2 도착 → P1(7) vs P2(4) → P2로 교체
[2]      P3 도착 → P2(3) vs P3(2) → P3로 교체
[3]      P4 도착 → P3(1) vs P4(1) → P3 유지
[4]      P3 종료 → P4 실행
[5]      P4 종료 → P2(3) 실행
[8]      P2 종료 → P1(7) 재실행
[15]     P1 종료

대기 시간 = 종료 - 도착 - 실행
P1: 15 - 0 - 8 = 7
P2: 8 - 1 - 4 = 3
P3: 4 - 2 - 2 = 0
P4: 5 - 3 - 1 = 1

평균 대기 시간 = (7 + 3 + 0 + 1)/4 = 2.75
```

--

##### 3. **Priority Scheduling** (선점형)
> 우선순위 높은 프로세스가 도착하면 현재 실행 중인 프로세스를 선점

- 장점: 중요한 작업 빠르게 처리
- 단점: 기아 가능성, 우선순위 변경 고려 필요 (Aging 필요)

[예시]

```plaintext
프로세스 도착 시간, 실행 시간, 우선순위: P1(0, 10, 3), P2(2, 1, 1), P3(3, 2, 4), P4(5, 1, 2)

실행 순서: P1(2) ➔ P2(1) ➔ P1(2) ➔ P4(1) ➔ P1(6) ➔ P3(2)

[0~2]   P1 실행 (10)
[2]     P2 도착 (우선순위 1) → P1 선점, P2 실행
[3]     P2 종료 → P1 재실행
[3]     P3 도착 (우선순위 4) → 무시 (P1보다 낮음)
[5]     P4 도착 (우선순위 2) → P1(우선순위 3)보다 높음 → P1 선점, P4 실행
[6]     P4 종료 → P1 재실행
[12]    P1 종료 → P3 실행
[14]    P3 종료

대기 시간 = 종료 - 도착 - 실행
P1 = 12 - 0 - 10 = 2
P2 = 3 - 2 - 1 = 0
P3 = 14 - 3 - 2 = 9
P4 = 6 - 5 - 1 = 0

평균 대기 시간 = (2 + 0 + 9 + 0)/4 = 2.75
```

---

#### 🎯 비선점 vs 선점

| 항목      | 비선점형                     | 선점형                    |
|---------|--------------------------|------------------------|
| CPU 회수  | 불가능 (스스로 반납해야 함)         | 가능 (운영체제가 강제로 교체)      |
| 문맥 전환   | 적음                       | 자주 발생해 오버헤드 큼          |
| 응답 속도   | 느림                       | 빠름 (인터렉티브에 유리)         |
| 예시 알고리즘 | FSFC, SJF, Priority(비선점) | RR, SRTF, Priority(선점) |


---

#### 🎤 면접 예상 질문
1. 선점형 스케줄링이란 무엇인가요?
   - 운영체제가 실행 중인 프로세스를 강제로 중단하고, 다른 프로세스에게 CPU 를 배정할 수 있는 방식입니다.
   - 대표적인 예로 Round Robin, SRTF, 선점형 Priority 등이 있습니다.
2. RR 과 SJF 의 차이는?
   - RR 은 일정 시간 단위로 프로세스를 교체하는 선점형 스케줄링 방식이고,
   - SJF 는 실행 시간이 짧은 프로세스를 우선으로 실행하는 비선점형 스케줄링 방식입니다.
3. 선점형 스케줄링의 단점은?
   - 문맥 전환이 자주 발생하며서 오버헤드가 커지고, 스레드 간 캐시 초기화, 메모리 접근 패턴 무효화 등 부작용이 있을 수 있습니다.
   - 따라서 Time Quantum, 우선순위 조정 등을 잘 설계해야 합니다.
