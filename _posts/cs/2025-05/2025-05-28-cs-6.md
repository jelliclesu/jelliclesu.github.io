---
title: "[CS] 인덱스: 인덱스 최적화 기법"
date: 2025-05-28 12:36:29 +0900
categories: [CS, 데이터베이스]
tags: [TIL, CS, 인덱스]
---
# CS 4장 데이터베이스
## 📚 4.5 인덱스

### 4.5.4 인덱스 최적화 기법

#### 📘 정의
- 쿼리 성능을 최대한 끌어올리기 위해 **인덱스를 잘 만들고, 잘 사용하고, 잘 유지 관리하는 전략**

---

#### 📌 기법
##### ⭐️ **필요한 곳에만 인덱스 생성**

| 기준             | 설명                          |
|----------------|-----------------------------|
| 자주 조회되는 컬럼     | WHERE, ORDER BY, JOIN 대상 컬럼 |
| 많은 데이터가 있는 테이블 | 수천, 수백만 건 이상일수록 효과 큼        |
| 자주 정렬, 필터되는 컬럼 | 날짜, 사용자, 상태 등               | 

- 자주 변경되는 컬럼을 인덱스로 설정하는 경우 오히려 성능 저하 유발

--

##### ⭐️ **복합 인덱스는 사용 패턴에 맞게 컴럼 순서 지정**

< `user_id + created_at` 설정 시 >

| 조건                       | 인덱스 사용 여부                  |
|--------------------------|----------------------------|
| `WHERE user_id`          | ✅ → OK                     |
| `WHERE created_at = ...` | ❌ 사용 불가 (Left-most rule 위반) |

- 인덱스를 분리하거나, 순서 재조정하여 해결 가능

--

##### ⭐️ **커버링 인덱스 사용**
- 쿼리 결과에 필요한 모든 컬럼이 인덱스에 포함되어 있으면, 
- **실제 테이블 접근 없이 인덱스만**으로 처리 ➔ 속도 대폭 향상

```sql
-- 커버링 인덱스 예시
CREATE INDEX idx_user_email_name ON user(email, name);

-- 쿼리
SELECT name FROM user WHERE email = 'a@a.com';
```

- 쿼리에 사용하는 `name` 과 `email` 가 모두 인덱스에 포함되어 있어, 인덱스만 읽고 결과 리턴 (빠름!)

--

##### ⭐️ **조건에 따라 인덱스 적용 여부 확인**

< **LIKE 연산 시** >

| 조건            | 인덱스 사용 여부           |
| ------------- | ------------------- |
| `LIKE 'abc%'` | ✅ 사용 가능 (접두어 매칭)    |
| `LIKE '%abc'` | ❌ 사용 불가 (뒤부터 탐색 불가) |

< **IS NULL, IS NOT NULL** >
- 대부분의 DB 에서는 IS NULL 조건도 인덱스 사용 가능이지만, DB 에 따라 다르므로 실행 계획 확인 필요!

--

##### ⭐️ **실행 계획 (EXPLAIN) 으로 인덱스 사용 여부 확인**

```sql
EXPLAIN SELECT * FROM user WHERE email = 'abc@naver.com';
```

```plaintext
type: ref
key: idx_user_email
rows: 1
```

- 결과에 `key = idx_user_email` 있으면 사용된 것

< type 종류 >

| type 값             | 의미                      | 성능                           |
| ------------------ | ----------------------- | ---------------------------- |
| `ALL`              | Full Table Scan         | ❌ 가장 느림                      |
| `index`            | Full Index Scan         | ⚠️ 인덱스를 끝까지 탐색 (비교 없이 전부 스캔) |
| `range`            | 범위 검색 (BETWEEN, <, >)   | ✅ 꽤 효율적                      |
| `ref`              | 인덱스를 사용한 조인 or WHERE 조건 | ✅ 인덱스를 통한 탐색 (동등 조건 비교)      |
| `eq_ref`           | 유일한 값을 조건으로 조인 (PK/FK)  | ✅ 가장 빠름                      |
| `const` / `system` | 상수처럼 취급되는 쿼리            | ✅ 최고 속도                      |

-- 

##### ⭐️ **정기적으로 인덱스 리빌드** 
- `UPDATE`/`DELETE` 가 많아지면 조각화 발생
- ➡︎ 정기적으로 `ANALYZE` (통계 수집), `REBUILD` (인덱스 재구성), `OPTIMIZE` (디스크 정리 + 분석) 수행

| 명령어              | 용도          | 설명                                                                                 |
| ---------------- | ----------- | ---------------------------------------------------------------------------------- |
| `ANALYZE TABLE`  | 통계 수집       | 테이블과 인덱스에 대한 **통계 정보 수집** → 옵티마이저가 쿼리 실행 계획을 더 정확하게 세움                             |
| `OPTIMIZE TABLE` | 디스크 정리 + 분석 | 테이블과 인덱스를 **재정렬(디프래그)** 하여 **공간 회수** 및 성능 향상 (InnoDB에선 `ALTER TABLE ... FORCE` 역할) |
| `REBUILD INDEX`  | 인덱스 재구성     | (MySQL에선 직접 사용 불가, 다른 DB용) 인덱스를 **완전히 다시 만드는 작업** → 조각화 심한 경우 사용됨                  |

```sql
ANALYZE TABLE user;
OPTIMIZE TABLE user;
```

--

##### ⭐️ **인덱스 과다 생성 금지**

- `INSERT`/`UPDATE` 느려짐 - 인덱스도 같이 수정되어야 하기 때문
- 디스크 공간 낭비 - 인덱스 파일은 별도 공간을 차지하므로
- 옵티마이저 혼란 - 너무 많은면 오히려 잘못된 인덱스 선택

---

#### 🎤 면접 예상 질문
1. 인덱스를 잘 만들었는데도 쿼리가 느립니다. 이유가 뭘까요?
   - 인덱스는 잘 만들어도 쿼리 패턴이 다르면 적용되지 않습니다.
   - 예를 들어 복합 인덱스에서 순서를 맞추지 않으면 적용되지 않고,
   - LIKE 는 접두어 매칭만 가능하며, OR 나 함수 사용 시에도 인덱스 사용은 불가합니다,
   - 따라서 실행계획을 통해 실제 적용 여부를 확인해야 합니다.
2. 커버링 인덱스란?
   - 쿼리가 사용하는 모든 컬럼이 인덱스 안에 들어있으면,
   - 테이블까지 가지 않고 인덱스마능로 결과를 반환하는 것을 말합니다.
   - 읽기 성능이 뛰어나며, 정렬/필터 조건이 동시에 포함될 때 효과적입니다.
