---
title: "[CS] ERD 와 정규화 과정: 정규화 (Normalization) 과정"
date: 2025-05-27 10:24:15 +0900
categories: [CS, 데이터베이스]
tags: [TIL, CS, ERD 와 정규화 과정]
---
# CS 4장 데이터베이스
## 📚 4.2 ERD 와 정규화 과정

### 4.2.3 정규화 (Normalization) 과정

#### 📘 정의
- 정규화 (Normalization)
  - 테이블을 **논리적으로 분해하여 데이터 중복을 줄이고**, **삽입/삭제/갱신 시 이상 현상(Anomaly) 을 방지**하는 설계 과정
  - 데이터 정합성(무결성)을 보장하며, 구조화된 DB 설계의 기반

---

#### 📌 필요 이유
- **이상 현상 (Anomaly) 방지**
  1. **삽입 이상**: 특정 속성이 없이 레코드를 삽입할 수 없음
  2. **삭제 이상**: 하나의 정보만 삭제하려다 다른 정보까지 함께 사라짐
  3. **갱신 이상**: 중복된 데이터 수정 시 누락/불일치 발생

---

#### 🎯 정규화 단계
##### ⭐️ **1NF** (제1 정규형)
- 속성의 **원자성 (Atomicity)**: 한 셀에는 하나의 값만

[예시]

| user_id | name | phone_numbers                |
|---------|------|------------------------------|
| 1       | 지수   | 010-1234-5678, 010-9876-5432 |

- `phone_numbers` 에 여러 값 ➔ **원자성 위반**

< **1NF 수행** >

| user_id | name |
|---------|------|
| 1       | 지수   |

| phone_id | phone_number  | user_id  |
|----------|---------------|----------|
| 1        | 010-1234-5678 | 1        |
| 2        | 010-9876-5432 | 1        |


- `Phone` 테이블로 분리하여 원자성 만족

--

##### ⭐️ **2NF** (제2 정규형)
- **부분 함수 종속** 제거: 기본 키가 두 개 이상의 속성으로 이루어진 복합 키일 때, **복합 키의 일부 속성만 참조하는 속성 제거**

[예시]

| student_id | course_id | student_name | course_name | grade |
|------------|-----------|--------------|-------------|-------|
| S001       | C101      | 지수           | 데이터베이스      | A+    |
| S001       | C102      | 지수           | 운영체제        | A     |
| S002       | C101      | 지투           | 데이터베이스      | B+    |

- `student_name` 은 `student_id` 만으로 결정 ➔ **부분 종속**
- `course_name` 은 `course_id` 만으로 결정 ➔ **부분 종속**

< **2NF 수행** >

| student_id | student_name |
| ---------- |--------------|
| S001       | 지수           |
| S002       | 지투           |

| course_id | course_name |
| --------- | ----------- |
| C101      | 데이터베이스      |
| C102      | 운영체제        |

| student_id | course_id | grade |
| ---------- | --------- | ----- |
| S001       | C101      | A+    |
| S001       | C102      | A     |
| S002       | C101      | B+    |

- `Student`, `Course`, `Grade` 테이블로 분리하여 부분 종속 제거

--

##### ⭐️ **3NF** (제3 정규형)
- **이행적 함수 종속** 제거: **기본 키가 아닌 컬럼에 의해 또 다른 컬럼이 결정되는 속성** 제거
- A ➔ B ➔ C 형태 (B 는 기본 키 아님) 라면, A ➔ C 관계 분리

[예시]

| user_id | name | zip_code | address  |
|---------|------|----------|----------|
| U001    | 지수   | 12345    | 서울시 강남구  |
| U002    | 지투   | 67890    | 부산시 해운대구 |
| U003    | 지원   | 12345    | 서울시 강남구  |

- `user_id` ➔ `zip_code` ➔ `address` = 이행 종속
- `zip_code` 는 기본 키가 아닌데 `address` 결정

< **3NF 수행** >

| user_id | name | zip_code |
| ------- |------| -------- |
| U001    | 지수   | 12345    |
| U002    | 지투   | 67890    |
| U003    | 지원   | 12345    |

| zip_code | address  |
| -------- | -------- |
| 12345    | 서울시 강남구  |
| 67890    | 부산시 해운대구 |

- `ZipCode` 테이블로 분리하여 이행 종속 제거

--

##### ⭐️ **BCNF** (보이스-코드 정규형)
- **모든 결정자**가 반드시 **후보 키**여야 한다는 원칙

[예시]

[강의 테이블]

| lecture | professor | room |
|---------|-----------|------|
| DB      | 김교수       | A101 |
| OS      | 이교수       | A102 |
| DB2     | 김교수       | A101 |

- 후보 키: `lecture`
- 후보 키가 아닌 `professor` 가 `room` 결정 ➔ BCNF 위반

< **BCNF 수행** >

| professor | room |
| --------- | ---- |
| 김교수       | A101 |
| 이교수       | A102 |

| lecture | professor |
| ------- | --------- |
| DB      | 김교수       |
| OS      | 이교수       |
| DB2     | 김교수       |

- `Professor_Room`, `Lecture` 테이블로 분리하여 모든 결정자가 후보 키

--

##### ⭐️ **4NF** (제4 정규형)
- **다치 종속** 제거: 하나의 기본 키에 대해 여러 개의 독립적인 다중 값 속성이 존재할 경우 이를 각각 테이블로 분리
- A ➔➔ B, A ➔➔ C: A: A 에 따라 B 도 여러 개, C 도 여러 개 존재하지만 B 와 C 는 서로 독립적

[예시]

| student_id | major | language |
|------------|-------|----------|
| S001       | 컴퓨터공학 | 영어       |
| S001       | 컴퓨터공학 | 일본어      |
| S001       | 수학    | 영어       |
| S001       | 수학    | 일본어      |

- `major` 와 `language` 는 무관하지만, 한 테이블에 있어서 중복 폭발 + 갱신 이상 발생 ➔ 다치 종속

< **4NF 수행** >

| student_id | major |
| ---------- | ----- |
| S001       | 컴퓨터공학 |
| S001       | 수학    |

| student_id | language |
| ---------- | -------- |
| S001       | 영어       |
| S001       | 일본어      |

- `Student_Major`, `Student_Language` 테이블 분리하여 다치 종속 제거

--

##### ⭐️ **5NF** (제5 정규형)
- **조인 종속** 제거: 여러 테이블로 나뉜 데이터를 조인해서 다시 원래 테이블이 되지 않는 경우 제거
- 비즈니스 규칙에 따라 다르게 판단되므로 실무에서 거의 적용하지 않음

---

#### ⚠️ **반정규화** (Denormalization)
> 정규화된 테이블을 다시 결합하거나 중복을 일부 허용하여, 조회 성능을 높이기 위한 최적화 과정

- ✔️ 필요 이유
  - 과도한 정규화로 테이블이 너무 분리되어 **JOIN 연산 과다 ➔ 조회 성능 저하**
  - 통계, 조회 데이터는 빠르게 읽어야 하기에 **실시간 조회 성능이 중요**함
  - 자주 쓰는 쿼리에 맞춰 구조를 재설계하여 **조회 쿼리 최적화**

- ✔️ 주의점
  - 수정 시 여러 테이블에서 동일 값 변경 필요
  - 트리거나 배치로 동기화하여 무결성 유지

- ✔️ 예시
  - `Order` + `User` 조인 후 자주 조회
    - ➔ `user_name` 을 `Order` 테이블에 중복 저장 (read-only 목적)

---

#### 🏢 실무 사용 여부
- 일반적으로 1NF ~ 3NF 까지 적용
- 정규화 + 인덱스 설계로 검색 속도와 데이터 정합성의 균형 고려
- 성능 고려로 필요 시 부분 반정규화 사용 ➔ 조인 연산 감소

---

#### 🎤 면접 예상 질문
1. 정규화는 왜 필요할까요?
   - 데이터 중복을 제거하고, 삽입/삭제/갱신 시 발생할 수 있는 이상 현상을 방지하여 무결성과 구조적 명확성을 확보할 수 있습니다.
2. 반정규화는 언제 필요한가요?
   - 지나치게 정규화된 테이블은 조인 연산이 많아 성능 저하를 일으킬 수 잇습니다.
   - 실시간 조회가 잦은 테이블에서는 일부 중복을 허용하고 조회 성능을 높이기 위해 반정규화를 적용합니다. 
3. 실무에서 정규화는 어디까지 하는지?
   - 일반적으로 3NF 또는 BCNF 까지 수행하는 것으로 알고 있습니다.
   - 실시간 성능이 중요한 경우에는 조회 성능을 위해 반정규화도 병행하며 설계 목적과 트래픽 특성을 고려해 유연하게 적용해야 합니다.
