---
title: "[CS] HTTP: HTTP/1.1"
date: 2025-05-17 15:18:32 +0900
categories: [CS, HTTP]
tags: [TIL, CS]
---
# CS
## 📚 2.5 HTTP

### 2.5.2 HTTP/1.1

#### 📘 정의
- 1997년에 발표된 HTTP 프로토콜
- **HTTP/1.0 의 비효율성과 한계를 개선한 버전**
- 대부분의 서버와 클라이언트가 HTTP/1.1 을 기본 지원!

⭐️ 주요 변화

| 개선점                            | 설명                                               |
|--------------------------------|--------------------------------------------------|
| **지속 연결 (Connection: keep-alive)** | 요청마다 TCP 연결을 새로 만들지 않고, 여러 요청을 하나의 연결에서 처리 가능    |
| **Host 헤더 필수화**                    | 하나의 IP 에서 여러 도메인을 운영할 수 있게 함 (가상 호스팅 지원)         |
| **파이프라이닝** (pipelining)            | 하나의 연결에서 여러 요청을 동시에 전송 (응답은 순서대로 옴)              |
| **캐싱 제어**                          | Cache-Control, ETag, Last-Modified 등 세부 캐시 정책 추가 |
| **상태 코드 추가**                       | 409 Conflict, 100 Continue 등 다양화                 |

---

#### 📌 주요 헤더 및 동작 흐름 예시

```http
GET /main HTTP/1.1
Host: www.example.com
Connection: keep-alive
```
- `Host`: 요청한 도메인이 무엇인지 명시
- `Connection: keep-alive`: TCP 연결 유지 요청

--

```plaintext
1. TCP 연결 생성 (1번만)
2. 클라이언트 → 서버에 여러 요청 전송
3. 서버 → 순서대로 응답
4. 연결을 계속 유지하거나, 필요 시 종료
```
- **TCP 연결 수가 줄어들고, 속도 개선 효과**

---

#### 🎯 장점
- 성능 개선 - 연결 재사용으로 오버헤드 감소
- 도메인 분리 가능 - Host 헤더 필수화로 가상 호스팅 완전 지원
- 캐싱 고도화 - 캐싱 명세 정교해짐
- 다양한 요청 처리 - `POST`, `PUT`, `DELETE` 등 명확한 메서드 지원

---

#### ⚠️ 단점
- **요청 직렬 처리** - 파이프라이닝 도입했지만, **응답은 순서대로라 병목 발생**
- HOL Blocking (Head-of-line Blocking) - 앞선 요청이 지연되면 **뒷 요청도 대기**
- 다중 요청 병렬성 부족 - CSS, JS, 이미지 동시 요청이 불리

---

#### 🏢 실무 사용 여부
✔️ 오늘날까지도 대부분의 서버/브라우저 기본값으로 HTTP/2 미지원 서버나 일부 API 서버는 여전히 HTTP/1.1 사용!

| 항목      | 설명                                             |
| ------- | ---------------------------------------------- |
| 🔹 브라우저 | 거의 모두 HTTP/2 우선 요청                             |
| 🔹 서버   | HTTP/2 지원 안 하면 1.1 fallback                    |
| 🔹 통계   | 2024년 기준 전 세계 웹사이트의 약 **65\~70%가 HTTP/2 사용 중** |


---

#### 🎤 면접 예상 질문
1. HTTP/1.0 과 HTTP/1.1 의 가장 큰 차이점은?
   - 연결 방식과 Host 헤더입니다.
   - HTTP/1.0 은 요청마다 TCP 연결을 새로 만들었지만,
   - HTTP.1.1 은 Connection: keep-alive 를 통해 지속 연결이 가능해졌습니다.
   - 또한, Host 헤더를 필수화하여 IP 하나로 여러 도메인을 운영할 수 있게 되었습니다.
2. HTTP/1.1 에서 성능 병목이 생기는 이유는?
   - 요청을 직렬로 처리하기 때문에 앞선 하나의 응답이 지연되면, 뒷 요청도 대기하게 됩니다.
   - 이를 해결하기 위해 나온 것이 HTTP/2 의 다중화 처리입니다.
3. 아직도 HTTP/1.1 을 사용하는 이유는?
   - 오래된 인프라와의 호환성, 간단한 REST API 요청, 경량 서비스에 적합하고,
   - 모든 브라우저/서버가 기본 지원하는 안정적인 버전이기 때문입니다.
