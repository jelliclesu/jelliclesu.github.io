---
title: "[JAVA] 백준 Silver II - 골드바흐 파티션(17103)"
date: 2025-05-29 09:06:58 +0900
categories: [Algorithm, 백준]
tags: [TIL, Algorithm]
---
# 코딩테스트 문제 풀이

## 📘 문제 제목
[백준 - 골드바흐 파티션](https://www.acmicpc.net/problem/17103)

### 🧠 문제 이해
- 짝수 N 을 두 소수의 합으로 나타낼 수 있을 때, 그 개수 구하기
- 두 소수의 순서만 다른 것은 같은 파티션

---

### ✏️ 슈도 코드

```plaintext
1. 소수 a
2. n - 소수 a 가 소수인지 판별
2. 소수라면 count++, 아니라면 a++
```

---

### 🔍 참고한 부분

```java
int max = 1000000;
boolean[] isNotPrime = new boolean[max + 1];
isNotPrime[0] = isNotPrime[1] = true;

for (int i = 2; i <= Math.sqrt(max); i++) {
  if (!isNotPrime[i]) {
    for (int j = i * i; j <= max; j += i) {
        isNotPrime[j] = true;
    }
  }
}
```
- 단순한 소수 판별법(**O(n√n)**)으로는 시간 초과

- **에라토스테네스의 체 알고리즘**
  - 시간 복잡도 **O(n(log log n))**
  - i 의 배수를 전부 지우는 방식

---

### ✅ 전체 코드
```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int T = sc.nextInt();

    int max = 1000000;
    boolean[] isNotPrime = new boolean[max + 1];
    isNotPrime[0] = isNotPrime[1] = true;

    for (int i = 2; i <= Math.sqrt(max); i++) {
      if (!isNotPrime[i]) {
        for (int j = i * i; j <= max; j += i) {
          isNotPrime[j] = true;
        }
      }
    }

    for (int i = 0; i < T; i++) {
      int n = sc.nextInt();

      if (n == 4) {
        System.out.println(1);
        continue;
      }

      int count = 0;
      for (int j = 3; j <= n / 2; j += 2) {
        if (!isNotPrime[j] && !isNotPrime[n - j]) {
          count++;
        }
      }
      System.out.println(count);
    }
  }
}
```
- 처음에 `isPrime` 메서드 만들어서 판별하니 시간초과 ← 각 테스트케이스마다 수행하기 때문에 비효율적
- `isNotPrime` 배열로 각 테스트케이스 실행 전 **미리 소수 여부 판별**
  - **에라토스테네스의 체 알고리즘**으로 시간 초과 방지
