---
title: "[JAVA] SWEA D3 - 최대 상금(1244)"
date: 2025-05-20 11:50:35 +0900
categories: [Algorithm, SWEA]
tags: [TIL, Algorithm]
---
# 코딩테스트 문제 풀이

## 📘 문제 제목
[SWEA - 최대 상금](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15Khn6AN0CFAYD)

### 🧠 문제 이해
- 정해진 횟수만큼 숫자를 교환했을 때 받을 수 있는 가장 큰 금액 계산하기
- 최대 자릿수 6, 최대 교환 횟수 10

처음에 그리디로 풀려고 생각하면서도 안될 것 같다해서 완전 탐색하려고 했는데,
완전 탐색도 또 아닌 것 같아서 일단 생각하기 쉬운 그리디로 먼저 그려봄

![img.png](/assets/img/algorithm/2025-05-20.png)


---

### 🥲 첫 코드 (그리디 이용)

```java
import java.util.*;

public class SWEA_1244_1 {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int[] num = Arrays.stream(sc.next().split(""))
      .mapToInt(Integer::parseInt)
      .toArray();
    int count = sc.nextInt();

    int swap = 0;
    String now = "";
    String prev = "";
    for (int i = 0; i < num.length; i++) {
      if (swap == 0 && i == num.length - 1) {
        int temp = num[i];
        num[i] = num[i - 1];
        num[i - 1] = temp;
        break;
      }
      int max = 0;
      int idx = 0;
      for (int j = i; j < num.length; j++) {
        max = Math.max(max, num[j]);
        if (max == num[j]) {
          idx = j;
        }
      }
      if (idx == i) continue;
      int temp = num[idx];
      num[idx] = num[i];
      num[i] = temp;
      swap++;
      String[] nowArr = Arrays.stream(num)
        .mapToObj(String::valueOf)
        .toArray(String[]::new);
      now = String.join("", nowArr);
      if (swap == count || prev.equals(now)) break;
      prev = now;
    }
    System.out.println(now);
  }
}
```
- 중복 숫자가 있는 경우 완벽하게 처리 부족
  - ex: 32888 -> 88823 (X)

---

### ✏️ 풀이 고민
- 최대 자릿수 6, 최대 교환 횟수 10 이므로 **완전 탐색 (DFS)** 으로 가능

---

### 🔍 전체 코드

```java
package com.prac.algorithm;

import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class SWEA_1244_2 {
  static int max = 0;
  static Set<String>[] visited;

  public static void main(String[] args) {
    Scanner sc= new Scanner(System.in);

    char[] num = sc.next().toCharArray();
    int count = sc.nextInt();

    max = 0;
    visited = new HashSet[count + 1];   // 각 깊이마다 방문한 문자열 저장용
    for (int i = 0; i <= count; i++) {
      visited[i] = new HashSet<>();
    }

    dfs(num, count, 0);

    System.out.println(max);
  }

  private static void dfs(char[] num, int count, int depth) {
    if (depth == count) {
      int n = Integer.parseInt(new String(num));
      max = Math.max(max, n);
      return;
    }

    String now = new String(num);
    if (visited[depth].contains(now)) return;   // 이미 depth 에 있는 값이면 탐색 필요 없음
    visited[depth].add(now);

    for (int i = 0; i < num.length - 1; i++) {
      for (int j = i + 1; j < num.length; j++) {
        swap(num, i, j);
        dfs(num, count, depth + 1);
        swap(num, i, j);    // 백트래킹
      }
    }
  }

  private static void swap(char[] num, int i, int j) {
    char temp = num[i];
    num[i] = num[j];
    num[j] = temp;
  }
}
```
- 전체 참고해서 풀이
- DFS, 백트래킹이 아직도 어려움,,ㅠㅠ
