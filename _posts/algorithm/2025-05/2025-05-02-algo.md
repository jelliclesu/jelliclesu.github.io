---
title: "[JAVA] 프로그래머스 Level 2 - 조이스틱"
date: 2025-05-02 11:34:34 +0900
categories: [Algorithm, 프로그래머스]
tags: [TIL, Algorithm]
---
# 코딩테스트 문제 풀이

## 📘 문제 제목

### 🧠 문제 이해
- 이름에 대해 조이스틱 조작 횟수의 최솟값

![img.png](/assets/img/algorithm/2025-05-02-1.png)

---

### ✏️ 슈도 코드

```plaintext
위아래:
  min('' - 'A', 'Z' - '' + 1)
왼오:
  min(left, right)
right = 전체 길이 - 1 - 마지막부터 연속된 'A' 의 개수
left = 전체 길이 - 1 - 2번째부터 연속된 'A' 의 개수
```

---

### 🔍 첫 코드

```java
import java.util.*;

class Solution {
  public int solution(String name) {
    // 위아래
    // min('' - 'A', 'Z' - '' + 1)
    int count = 0;
    for (char ch : name.toCharArray()) {
      count += Math.min(ch - 'A', 'Z' - ch + 1);
    }

    // 왼오
    // min(left, right)
    int len = name.length();
    // 오른쪽으로 가는 경우
    // 전체 길이 - 마지막부터 연속된 'A'의 갯수
    int rightA = 0;
    for (int i = len - 1; i > 0; i--) {
      if (name.charAt(i) == 'A') {
        rightA++;
      } else break;
    }
    int right = len - 1 - rightA;
    // 왼쪽으로 가는 경우
    // 2번째부터 연속된 'A'의 갯수
    int leftA = 0;
    for (int i = 1; i <= len - 1; i++) {
      if (name.charAt(i) == 'A') {
        leftA++;
      } else break;
    }
    int left = len - 1 - leftA;

    count += Math.min(right, left);
    return count;
  }
}
```
- 정확성: 59.3 으로 실패
- 오른쪽으로 가다가 왼쪽으로 가거나 등의 우회 경우 고려하지 않음

---

### ✏️ 우회 경우 생각하기 (참고)

```plaintext
오른쪽으로 가다가 연속 A 만나서 돌아가는 경우:
  오른쪽 이동 횟수(i) * 2 (되돌아가기) + 왼쪽 이동 횟수(전체 길이 - 연속 'A' 개수)
왼쪽으로 가다가 연석 A 만나서 돌아가는 경우:
  왼쪽 이동 횟수(전체 길이 - 연속 'A' 개수) * 2 + 오른쪽 이동 횟수(i)
```

---

### ✅ 전체 코드
```java
class Solution {
  public int solution(String name) {
    int len = name.length();
    int move = len - 1;
    int count = 0;

    for (int i = 0; i < len; i++) {
      char ch = name.charAt(i);
      // 위아래
      count += Math.min(ch - 'A', 'Z' - ch + 1);

      // 다음 위치부터 연속된 'A'의 개수
      int next = i + 1;
      while (next < len && name.charAt(next) == 'A') {
        next++;
      }

      // 왼오 최소값 구하기
      move = Math.min(move, (i * 2) + len - next);    // 오른쪽으로 가다가 우회
      move = Math.min(move, (len - next) * 2 + i);    // 왼쪽으로 가다가 우회
    }

    return count + move;
  }
}
```
