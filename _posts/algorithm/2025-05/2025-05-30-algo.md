---
title: "[JAVA] í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ Level 3 - ì„¬ ì—°ê²°í•˜ê¸°"
date: 2025-05-30 14:38:19 +0900
categories: [Algorithm, í”„ë¡œê·¸ë˜ë¨¸ìŠ¤]
tags: [TIL, Algorithm]
---
# ì½”ë”©í…ŒìŠ¤íŠ¸ ë¬¸ì œ í’€ì´

## ğŸ“˜ ë¬¸ì œ ì œëª©
[í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ - ì„¬ ì—°ê²°í•˜ê¸°](https://school.programmers.co.kr/learn/courses/30/lessons/42861)

### ğŸ§  ë¬¸ì œ ì´í•´
- n ê°œì˜ ì„¬ ì‚¬ì´ì— ë‹¤ë¦¬ë¥¼ ê±´ì„¤í•˜ëŠ” ë¹„ìš©ì´ ì£¼ì–´ì§ˆ ë•Œ, ëª¨ë“  ì„¬ì´ ì„œë¡œ í†µí–‰ ê°€ëŠ¥í•˜ë„ë¡ ë§Œë“¤ ë•Œ í•„ìš”í•œ ìµœì†Œ ë¹„ìš©

---

### âœï¸ ìŠˆë„ ì½”ë“œ

```plaintext
1. ë¹„ìš© ê¸°ì¤€ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
2. !visited[cost[1]] ? 
    vistied[cost[1]] = true;
    answer += cost[2];
    count++;
```

---

### 1ï¸âƒ£ ì²« ì½”ë“œ

```java
import java.util.*;

class Solution {
  public int solution(int n, int[][] costs) {
    Arrays.sort(costs, (a, b) -> a[2] - b[2]);

    boolean[] visited = new boolean[n];
    visited[costs[0][0]] = true;
    int count = 1;
    int answer = 0;

    for (int[] cost : costs) {
      if (count == n) break;

      if (!visited[cost[1]]) {
        visited[cost[1]] = true;
        answer += cost[2];
        count++;
      }
    }

    return answer;
  }
}
```
- ì˜ˆì‹œëŠ” í†µê³¼í•˜ëŠ”ë° ì •í™•ì„± í…ŒìŠ¤íŠ¸ì—ì„œ 1ê°œ ë¹¼ê³  ì‹¤íŒ¨
- MST ê°€ ì œëŒ€ë¡œ ë§Œë“¤ì–´ì§€ì§€ ì•Šì•„ì„œ ë¬¸ì œ! ~~(ì§€í”¼í‹°í•œí…Œ ë°˜ë¡€ ì•Œë ¤ë‹¬ë¼í–ˆë”ë‹ˆ ì œëŒ€ë¡œ ì•ˆì•Œë ¤ì¤Œ)~~

---

### ğŸ” ì°¸ê³ í•œ ë¶€ë¶„

```java
if ((visited[from] && !visited[to]) || (!visited[from] && visited[to])) {
```

- MST í™•ì¸ì„ ìœ„í•´ ë‘˜ ì¤‘ì— í•˜ë‚˜ì˜ ì„¬ì´ë¼ë„ ì—°ê²°ëœ ìƒíƒœì¸ì§€ í™•ì¸ í›„ ì²˜ë¦¬í•´ì•¼ í•¨

---

### âœ… ì „ì²´ ì½”ë“œ
```java
import java.util.*;

class Solution {
  public int solution(int n, int[][] costs) {
    Arrays.sort(costs, (a, b) -> a[2] - b[2]);

    boolean[] visited = new boolean[n];
    visited[costs[0][0]] = true;
    int count = 1;
    int answer = 0;

    while (count < n) {
      for (int[] cost : costs) {
        int from = cost[0];
        int to = cost[1];
        int weight = cost[2];

        if ((visited[from] && !visited[to]) || (!visited[from] && visited[to])) {
          visited[from] = true;
          visited[to] = true;
          answer += weight;
          count++;
          break;
        }
      }
    }

    return answer;
  }
}
```

--- 

### â­ï¸ ì‹œê°„ ë‹¨ì¶•

```java
import java.util.*;

class Solution {
  public int solution(int n, int[][] costs) {
    Arrays.sort(costs, (a, b) -> Integer.compare(a[2], b[2]));
    int bridge = 0;
    int answer = 0;

    UnionFind uf = new UnionFind(n);

    for (int[] cost : costs) {
      int a = cost[0];
      int b = cost[1];
      int c = cost[2];
      if (uf.find(a) != uf.find(b)) {
        answer += c;
        uf.union(a, b);
        bridge++;
      }

      if (bridge == n - 1) {
        break;
      }
    }
    return answer;
  }
}

class UnionFind {
  private int[] parent;

  // ì´ˆê¸°í™” (ê° ë…¸ë“œëŠ” ìê¸° ìì‹ ì„ ë¶€ëª¨ë¡œ ê°€ì§)
  public UnionFind(int n) {
    parent = new int[n];
    for (int i = 0; i < n; i++) {
      parent[i] = i;
    }
  }

  // Find (ê²½ë¡œ ì••ì¶• ì ìš©)
  public int find(int x) {
    if (parent[x] == x) return x;
    return parent[x] = find(parent[x]);
  }

  // Union (ë‘ ì§‘í•©ì„ í•©ì¹¨)
  public void union(int a, int b) {
    int rootA = find(a);
    int rootB = find(b);
    if (rootA != rootB) {  // ì‚¬ì´í´ì´ ë°œìƒí•˜ì§€ ì•Šìœ¼ë©´ ë³‘í•©
      parent[rootB] = rootA;
    }
  }
}
```
- MST ëŠ” Union-Find ë¡œ êµ¬í˜„ ê°€ëŠ¥
