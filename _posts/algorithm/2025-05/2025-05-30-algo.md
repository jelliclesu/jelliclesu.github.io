---
title: "[JAVA] 프로그래머스 Level 3 - 섬 연결하기"
date: 2025-05-30 14:38:19 +0900
categories: [Algorithm, 프로그래머스]
tags: [TIL, Algorithm]
---
# 코딩테스트 문제 풀이

## 📘 문제 제목
[프로그래머스 - 섬 연결하기](https://school.programmers.co.kr/learn/courses/30/lessons/42861)

### 🧠 문제 이해
- n 개의 섬 사이에 다리를 건설하는 비용이 주어질 때, 모든 섬이 서로 통행 가능하도록 만들 때 필요한 최소 비용

---

### ✏️ 슈도 코드

```plaintext
1. 비용 기준 오름차순 정렬
2. !visited[cost[1]] ? 
    vistied[cost[1]] = true;
    answer += cost[2];
    count++;
```

---

### 1️⃣ 첫 코드

```java
import java.util.*;

class Solution {
  public int solution(int n, int[][] costs) {
    Arrays.sort(costs, (a, b) -> a[2] - b[2]);

    boolean[] visited = new boolean[n];
    visited[costs[0][0]] = true;
    int count = 1;
    int answer = 0;

    for (int[] cost : costs) {
      if (count == n) break;

      if (!visited[cost[1]]) {
        visited[cost[1]] = true;
        answer += cost[2];
        count++;
      }
    }

    return answer;
  }
}
```
- 예시는 통과하는데 정확성 테스트에서 1개 빼고 실패
- MST 가 제대로 만들어지지 않아서 문제! ~~(지피티한테 반례 알려달라했더니 제대로 안알려줌)~~

---

### 🔍 참고한 부분

```java
if ((visited[from] && !visited[to]) || (!visited[from] && visited[to])) {
```

- MST 확인을 위해 둘 중에 하나의 섬이라도 연결된 상태인지 확인 후 처리해야 함

---

### ✅ 전체 코드
```java
import java.util.*;

class Solution {
  public int solution(int n, int[][] costs) {
    Arrays.sort(costs, (a, b) -> a[2] - b[2]);

    boolean[] visited = new boolean[n];
    visited[costs[0][0]] = true;
    int count = 1;
    int answer = 0;

    while (count < n) {
      for (int[] cost : costs) {
        int from = cost[0];
        int to = cost[1];
        int weight = cost[2];

        if ((visited[from] && !visited[to]) || (!visited[from] && visited[to])) {
          visited[from] = true;
          visited[to] = true;
          answer += weight;
          count++;
          break;
        }
      }
    }

    return answer;
  }
}
```

--- 

### ⭐️ 시간 단축

```java
import java.util.*;

class Solution {
  public int solution(int n, int[][] costs) {
    Arrays.sort(costs, (a, b) -> Integer.compare(a[2], b[2]));
    int bridge = 0;
    int answer = 0;

    UnionFind uf = new UnionFind(n);

    for (int[] cost : costs) {
      int a = cost[0];
      int b = cost[1];
      int c = cost[2];
      if (uf.find(a) != uf.find(b)) {
        answer += c;
        uf.union(a, b);
        bridge++;
      }

      if (bridge == n - 1) {
        break;
      }
    }
    return answer;
  }
}

class UnionFind {
  private int[] parent;

  // 초기화 (각 노드는 자기 자신을 부모로 가짐)
  public UnionFind(int n) {
    parent = new int[n];
    for (int i = 0; i < n; i++) {
      parent[i] = i;
    }
  }

  // Find (경로 압축 적용)
  public int find(int x) {
    if (parent[x] == x) return x;
    return parent[x] = find(parent[x]);
  }

  // Union (두 집합을 합침)
  public void union(int a, int b) {
    int rootA = find(a);
    int rootB = find(b);
    if (rootA != rootB) {  // 사이클이 발생하지 않으면 병합
      parent[rootB] = rootA;
    }
  }
}
```
- MST 는 Union-Find 로 구현 가능
