---
title: "[JAVA] 백준 Gold IV - N-Queen(9663)"
date: 2025-06-30 12:13:38 +0900
categories: [Algorithm, 백준]
tags: [TIL, Algorithm]
---
# 코딩테스트 문제 풀이

## 📘 문제 제목
[벡준 - N-Queen](https://www.acmicpc.net/problem/9663)

### 🧠 문제 이해
- N x N 체스판 위에 퀸 N 개를 서로 공격할 수 없게 놓는 문제 
- 퀸은 상하좌우, 대각선 모든 방향으로 원하는 만큼 이동 가능 
- 단, 본인의 기물을 뛰어넘을 수 없음

1. 한 행에 하나씩 (i)
2. 한 열에 하나씩 (j != i)
3. 한 대각선에 하나만 존재 
   - 기존에 선택된 (x, y)
   - abs(x - i) != abs(y - j) 

✚ 대각선은 i + j 가 같던가 i - j 가 같음 
-> 즉, i + j 혹은  i - j 가 true 이면 같은 대각선임

---

### ✏️ 첫 슈도 코드

```plaintext
queen():
  !visitedCol[j]:
    list :
      abs(x - i) == abs(y - j):
        inLine = true;
    !inLine:
      visited[j] = true;
      queen()
      visited[j] = false;
```

---

### 1️⃣ 첫 코드

```java
import java.util.*;

public class Main {
    public static int N;
    public static boolean[] visitedRow;
    public static boolean[] visitedCol;
    public static ArrayList<int[]> list = new ArrayList<>();
    public static int count;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        N = sc.nextInt();
        visitedRow = new boolean[N];
        visitedCol = new boolean[N];
        
        queen(0);
        System.out.println(count);
    }

    private static void queen(int row) {
        if (row == N) {
            if (list.size() == N) {
                count++;
            }
            return;
        }

        for (int j = 0; j < N; j++) {
            if (!visitedCol[j]) {
                boolean inLine = false;
                if (!list.isEmpty()) {
                    for (int[] arr : list) {
                        if (Math.abs(arr[0] - row) == Math.abs(arr[1] - j)) {
                            inLine = true;
                            break;
                        }
                    }
                }
                if (!inLine) {
                    visitedCol[j] = true;
                    list.add(new int[]{row, j});
                    queen(row + 1);
                    list.remove(list.size() - 1);
                    visitedCol[j] = false;
                }
            }
        }
    }
}
```

- 예시 테스트 케이스는 잘 되는데 메모리 초과
- 찾아보니 `list.remove` 가 메모리 오버헤드 초래할 수 있다는 의견이 있음
- 대각선 탐색하는 것도 `boolean` 으로 하면 메모리 낭비 줄일 수 있음

---

### 🔍 참고한 부분

```java
visitedDiag1 = new boolean[2 * N - 1];
visitedDiag2 = new boolean[2 * N - 1];

!visitedCol[col] && !visitedDiag1[row - col + (N - 1)] && !visitedDiag2[row + col]
```
- `\` 방향 대각선은 `row` - `col` 의 값이 같음 -> `row` - `col` 은 음수가될 수 있으므로 N - 1 만큼 더해서 양수로!
- `/` 방향 대각선은 `row` + `col` 의 값이 같음
- 배열 크기는 `row` + `col` -> 2N - 1 로 설정

---

### ✅ 전체 코드
```java
import java.util.*;

public class Main {
    public static int N;
    public static boolean[] visitedCol;
    public static boolean[] visitedDiag1;
    public static boolean[] visitedDiag2;
    public static int count = 0;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        N = sc.nextInt();
        visitedCol = new boolean[N];
        visitedDiag1 = new boolean[2 * N - 1];
        visitedDiag2 = new boolean[2 * N - 1];
        
        queen(0);
        System.out.println(count);
    }

    private static void queen(int row) {
        if (row == N) {
            count++;
            return;
        }

        for (int col = 0; col < N; col++) {
            if (!visitedCol[col] && !visitedDiag1[row - col + (N - 1)] && !visitedDiag2[row + col]) {
                visitedCol[col] = true;
                visitedDiag1[row - col + (N - 1)] = true;
                visitedDiag2[row + col] = true;

                queen(row + 1);

                visitedCol[col] = false;
                visitedDiag1[row - col + (N - 1)] = false;
                visitedDiag2[row + col] = false;
            }
        }
    }
}
```
