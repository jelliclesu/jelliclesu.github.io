---
title: "[JAVA] 백준 Silver V - 다리 놓기(1010)"
date: 2025-06-13 09:16:13 +0900
categories: [Algorithm, 백준]
tags: [TIL, Algorithm]
---
# 코딩테스트 문제 풀이

## 📘 문제 제목
[백준 - 다리 놓기](https://www.acmicpc.net/problem/1010)

### 🧠 문제 이해
- N < M 일 때, N 개만큼 다리를 지울 수 있는 경우의 수
- 다리는 서로 겹쳐질 수 없음 -> 항상 전 사이트가 선택한 수보다 큰 수 선택
- 하나의 사이트에는 한 개의 다리만 연결 가능
- => 단순 조합 M 개 중에 N 개를 고르는 경우 

---

### ✏️ 참고 사항

```plaintext
1. 동쪽에서 N개를 선택한다고 해봅시다. 
   선택된 인덱스를 j₁ < j₂ < ... < jₙ 이라고 할 수 있음.

2. 서쪽의 i번째는 항상 동쪽의 jᵢ번째와 매칭됩니다.
   즉, 순서쌍 (S₁ → D_{j₁}, S₂ → D_{j₂}, ..., Sₙ → D_{jₙ})

3. 오름차순 조건 때문에,
   서로 겹치지 않으면서 순서만 지켜주는 매칭이므로
   가능한 경우는 M개 중 N개를 선택하는 조합의 수와 같음.
```

---

### 1️⃣ 첫 코드

```java
import java.util.Scanner;

public class BOJ_1010_1 {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int T = sc.nextInt();

    for (int i = 0; i < T; i++) {
      long N = sc.nextInt();
      long M = sc.nextInt();

      System.out.println(fac(M) / (fac(N) * fac(M - N)));
    }
  }

  private static long fac(long n) {
    if (n <= 1) return 1;
    return n * fac(n - 1);
  }
}
```
- `fac(M)` 이 `long` 의 범위를 넘어가면서 음수가 되어 계산 오류!

---

### 🔍 참고한 부분

```java
private static long comb(int m, int n) {
  long result = 1;
  for (int i = 1; i <= n; i++) {
    result *= m--;
    result /= i;
  }
  return result;
}
```
---

### ✅ 전체 코드
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();

        for (int i = 0; i < T; i++) {
            int N = sc.nextInt();
            int M = sc.nextInt();

            System.out.println(comb(M, N));
        }
    }

    private static long comb(int m, int n) {
        long result = 1;
        for (int i = 1; i <= n; i++) {
            result *= m--;
            result /= i;
        }
        return result;
    }
}
```
- 조합 계산으로 변경
