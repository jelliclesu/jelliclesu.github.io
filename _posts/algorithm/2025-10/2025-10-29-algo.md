---
title: "[JAVA] 프로그래머스 Level 2 - 전화번호 목록"
date: 2025-10-29 18:42:10 +0900
categories: [Algorithm, 프로그래머스]
tags: [TIL, Algorithm]
---
# 코딩테스트 문제 풀이

## 📘 문제 제목
[프로그래머스 - 전화번호 목록](https://school.programmers.co.kr/learn/courses/30/lessons/42577)

### 🧠 문제 이해
- 어떤 번호가 다른 번호의 접두어인 경우 -> false

- 방법1. substring 으로 잘라서 set 에 넣기 -> 정확성 37.5
- 방법2. startsWith 으로 이중 for 문 -> 효율성 테스트에서 시간 초과
- 방법3. startsWith 으로 for 문 (정렬 특성 고려)

---

### ✏️ 슈도 코드

```plaintext
정렬

방법1. 
phone : phone_book 
  phone.substring(0, i)
  set.contains() ? false
  
방법2.
phone_book[i].startsWith(phone_book[j]) ? false

방법3.
phone_book[i + 1].starsWith(phone_book[i]) ? false
```

---

### 🔍 참고한 부분

```java
// 문자열이 특정 문자로 시작하는지 확인하는 메서드
boolean startsWith(String prefix);
```

#### 접두어 관계의 특성
문자열 A가 B의 접두어라면, 사전순으로 정렬했을 때 반드시 “A가 B보다 앞에 위치”
=> 즉, 접두어 관계가 있다면 항상 두 문자열은 ‘연속된 위치’에 등장

| 원본 배열                             | 정렬 후                              |
| --------------------------------- | --------------------------------- |
| ["119", "97674223", "1195524421"] | ["119", "1195524421", "97674223"] |



---

### ✅ 전체 코드
```java
import java.util.*;

class Solution {
  public boolean solution(String[] phone_book) {
    Arrays.sort(phone_book);

    for (int i = 0; i < phone_book.length - 1; i++) {
      if (phone_book[i + 1].startsWith(phone_book[i])) {
        return false;
      }
    }

    return true;
  }
}
```
- 정렬이 끝나면 모든 “접두어 후보 쌍”은 인접하게 모이게 되므로, 각 문자열 phone_book[i]와 바로 다음 문자열 phone_book[i + 1]만 비교해도 충분
