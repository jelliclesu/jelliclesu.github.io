---
title: "[DB] 데이터베이스 인덱스"
date: 2025-10-31 17:03:52 +0900
categories: [매일메일, Database]
tags: [TIL, Database]
---
## 데이터베이스 인덱스

> 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
책의 색인(index)과 같은 역할


### 특징

- 데이터를 찾을 때 전체 테이블을 읽지 않고, 일부만 빠르게 탐색하도록 도움
- 저장되는 특정 컬럼을 기준으로 항상 정렬된 상태 유지
- 검색, 정렬, 조인 성능을 높이는 대신, 쓰기 성능(INSERT, UPDATE, DELETE)은 일부 희생

---

## 인덱스의 기본 구조

- **B+Tree** 구조로 구현(MySQL InnoDB 기준)

### B+Tree 인덱스

> 데이터가 균형 있게 분포된 다단계 트리 구조


### B+Tree 구성 요소

- 루트 노드(Root Node): 트리의 최상위 노드, 검색의 시작점
- 브랜치 노드(Branch Node): 탐색을 위한 중간 단계, 다음 노드로 이동하기 위한 경로 정보 저장
- 리프 노드(Leaf Node): 실제 인덱스 키 값과 데이터의 주소 저장

### 작동 방식

1. 루트 노드에서 시작하여 검색 키 값 비교
2. 해당 키 범위를 포함하는 브랜치 노드로 이동
3. 최종적으로 리프 노드에서 원하는 키(또는 PK) 탐색

---

## InnoDB

> MySQL의 기본 스토리지 엔진으로, 트랜잭션, 외래 키, Row-Level Locking 지원


### 1. 클러스터드 인덱스 (Clustered Index)

- 테이블의 기본 키(PK)로 자동 생성되는 인덱스로 항상 클러스터드 인덱스로 정렬되어 저장
- 리프 노드에 실제 데이터 row 가 함께 저장 → 인덱스 자체가 데이터 저장 구조 역할
- PK 기반 검색으로 매우 빠른 탐색 (`O(logN)`) 이 가능하지만, PK 크기가 클 경우 인덱스 공간 낭비 및 성능 저하 가능

### 2. 세컨더리 인덱스 (Secondary Index)

- PK 외의 컬럼에 대해 개발자가 직접 생성하는 인덱스
- 리프 노드에 실제 데이터 대신 해당 row 의 PK 값 저장
- 2 번의 B+Tree 탐색 필요 (=더블 루킹)
  1. 세컨더리 인덱스에서 조건에 맞는 PK 조회
  2. 해당 PK로 클러스터드 인덱스를 다시 탐색하여 실제 row 접근

---

## MySQL의 주요 인덱스 스캔 방식

### Index Range Scan (인덱스 범위 스캔)

> 인덱스의 특정 범위를 순차적으로 스캔


```sql
SELECT * FROM user WHERE age BETWEEN 20 AND 30;
```

1. 인덱스에서 조건에 맞는 시작 리프 노드를 찾고
2. 필요한 범위만 순차적으로 스캔
3. 인덱스 키를 통해 실제 레코드를 찾아옴

→ 가장 일반적이고 빠른 방식

### Index Full Scan (인덱스 전체 스캔)

> 인덱스를 처음부터 끝까지 모두 스캔


```sql
SELECT B FROM user WHERE C = 'Y';
```

- 인덱스가 A, B, C 순으로 생성되어 있을 때, 첫 컬럼 A가 조건에 없으면 Index Range Scan 불가

  → Index Full Scan 수행

- 인덱스 전체를 순회하지만 테이블 전체 읽기보다 낫고, 데이터까지 접근하지 않을 수도 있음

### Loose Index Scan (루스 인덱스 스캔)

> 인덱스 중 일부를 건너뛰며 필요한 값만 스캔


```sql
SELECT dept_id, MAX(salary)
FROM employee
GROUP BY dept_id;
```

- 각 그룹별로 필요한 부분만 인덱스 접근
- `GROUP BY`, `DISTINCT`, `MAX()`, `MIN()` 쿼리 최적화 시 사용

---

## 인덱스 장단점

### 장점

1. 조회 성능이 향상되어 빠른 탐색이 가능
2. `ORDER BY`, `GROUP BY` 시 추가 정렬 불필요
3. `UNIQUE INDEX` 로 무결성 보장되어 데이터 중복 방지
4. 조인 키를 기준으로 빠른 탐색이 가능해 조인 성능 향상

### 단점

1. 쓰기(`INSERT`/`UPDATE`/`DELETE`) 시 인덱스 정렬 유지 비용 발생
2. 인덱스가 많을수록 데이터 수정 시 오버헤드 증가
3. 인덱스 저장으로 디스크 공간 사용량 증가
4. 인덱스 선정/설계가 잘못되면 오히려 성능 저하

---

## 설계 시 주의사항

- **선택도(Selectivity)**: 값의 중복이 적을수록 인덱스 효율 증가 (ex. 주민번호, 이메일 등)
- **카디널리티(Cardinality)**: 데이터의 다양성이 높을수록 효율 증가
- **컬럼 순서 중요**: 복합 인덱스는 왼쪽 우선 원칙에 따라 탐색되므로 순서 선정 중요
- **불필요한 인덱스 금지**: 인덱스는 메모리와 I/O 비용이 크므로 필요한 컬럼만 설정
- **쓰기 부하 고려**: 인덱스 남발 시 쓰기 성능 저하 가능

---

참고: [maeil-mail 매일메일 - 데이터베이스 인덱스에 대해서 설명해주세요.](https://www.maeil-mail.kr/question/60)
