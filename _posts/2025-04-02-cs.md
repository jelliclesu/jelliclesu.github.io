---
title: "[CS] 디자인 패턴, 싱글톤 패턴(Singleton)"
date: 2025-04-02 19:44:15 +0900
categories: ["2025-04-02", CS]
tags: [TIL, CS, 디자인 패턴]
---
# CS
## 📚 1.1 디자인 패턴 (Design Pattern)
- 소프트웨어 설계에서 자주 발생하는 문제를 해결하기 위한, 재사용 가능한 설계 방법
- 즉, 효율적이고 유지보수하기 쉬운 코드 구조를 만들기 위함!

#### 디자인 패턴 탄생 배경
- 프로그래밍을 하다 보면 같은 구조의 문제를 여러 번 마주치고, 비슷한 방식으로 해결하게 됨
  - 이걸 매번 새롭게 고민하지 않고, 검증된 해결책을 설계 패턴으로 정리해두자!

#### 언제 쓰면 좋을까?
- 코드 중복을 줄이고 싶을 때
- 클래스 간의 결합도를 낮추고 싶을 때
- 유지보수하기 좋은 구조를 만들고 싶을 때
- 확장성과 유연성을 높이고 싶을 때

#### 디자인 패턴 분류 (GoF(Gang of Four))

| 분류 | 목적 | 대표 패턴                                                         |
|------|------|---------------------------------------------------------------|
| **생성(Creational)** | 객체 생성 방법을 제어 | 싱글톤, 팩토리, 추상 팩토리, 빌더, 프로토타입                                   |
| **구조(Structural)** | 클래스/객체 조합 구조 설계 | 어댑터, 프록시, 데코레이터, 컴포지트, 브리지, 퍼사드, 플라이웨이트                       |
| **행위(Behavioral)** | 객체 간의 상호작용 설계 | 전략, 옵저버, 이터레이터, 상태, 커맨드, 책임 연쇄, 인터프리터, 메멘토, 템플릿 메서드, 방문자, 중재자 |

- 총 23가지 패턴

#### Spring 연관성
- 디자인 패턴의 개념을 이해하고 있어야 코드의 흐름과 구조를 이해할 수 있음
- Spring 자체가 여러 디자인 패턴 기반으로 만들어짐
  - ex)
  - @Component, @Service ➔ 싱글톤 패턴
  - AOP ➔ 프록시 패턴
  - Strategy 인터페이스 활용 ➔ 전략 패턴

---

### 1.1.1 싱글톤 패턴 (Singleton)
#### 정의
- 특정 클래스의 **인스턴스를 오직 하나**만 **생성**하고, 이 인스턴스를 전역적으로 공유하도록 보장하는 디자인 패턴
- 즉, 객체가 단 하나만 존재하도록 **생성 자체를 제한**하고, 필요한 곳에서 **이 인스턴스에 접근**할 수 있게 하는 것이 핵심

➡︎ **객체를 딱 하나만 만들고, 그걸 전역에서 공유하게 해주는 패턴!**

#### 예시 상황
1. 로그 시스템 (Logger)
   - 로그 기록은 앱 전체에서 이루어지는데, 여러 개의 Logger 인스턴스가 존재하면 로그 중복, 순서 꼬임 등의 문제 발생
2. 설정값 관리 (Config)
   - 앱 전체 설정값을 로딩하는 객체는 하나만 있어야 함! 여러 개가 있으면 서로 다른 설정을 들고 있을 수 있음
3. DB 커넥션 풀 관리자
   - 리소스를 많이 쓰기 때문에, 한 객체에서 효율적으로 풀을 관리하게 해야 함
4. 캐시 관리자
   - 시스템 전체에서 동일한 캐시 데이터를 공유해야 할 때!

#### 사용 이유 / 장점
1. 인스턴스를 하나만 만들기에 메모리 절약
   - 불필요한 객체 생성을 막을 수 있음
2. 전역 접근 포인트 제공
   - 어디서든 _Singleton.getInstance()_ 처럼 쉽게 접근 가능
3. 상태 일관성 유지
   - 설정값, 로깅, 캐시 등에서 상태를 공유할 때 유리
4. 생성 제어
   - 객체 생성을 직접 통제할 수 있어 생성 시점이나 방식에 유연성 부여 가능

#### 단점
1. 테스트 어려움
   - 싱글톤은 상태를 공유하므로, 테스트 간 영향을 줄 수 있음
   - 테스트에서 객체를 재설정하거나 교체하기 어려움
2. 의존성 주입(DI) 와 충돌
   - 외부에서 객체를 주입받는 구조(DI) 와 충돌될 수 있어서 유연한 설계가 힘들어짐
3. 멀티스레드 환경에선 동기화 필요
   - 멀티스레드 환경에서 동시에 접근하면 중복 인스턴스가 생길 수 있으므로 _synchronized_, _volatile_ 등으로 처리해야 안전

#### 실무 사용 여부
- 실무에서 사용되지만, 직접 구현하는 경우는 많지 않음
- 단, 이론과 구현 원리는 이애하고 있어야 함

#### JAVA/Spring 예시
##### Java 
- 생성자를 private 로 막고, 정적 메서드로 인스턴스를 리턴하는 방식으로 구현

[Java 코드 예시]

```java
public class Singleton {
  private static final Singleton instance = new Singleton();

  private Singleton() {}

  public static Singleton getInstance() {
    return instance;
  }
}

```
[멀티스레드 환경에서 안전한 싱글톤 구현: double-checked locking]

```java
public class Singleton {
  private static volatile Singleton instance;

  private Singleton() {}

  public static Singleton getInstance() {
    if (instance == null) {
      synchronized (Singleton.class) {
        if (instance == null) {
          instance = new Singleton();
        }
      }
    }
    return instance;
  }
}

```
- _synchronized_, _volatile_ 을 활용한 **double-checked locking** 기법 사용

[멀티스레드 환경에서 안전한 싱글톤 구현: enum]

```java
public enum Singleton {
  INSTANCE;

  public void doSomething() {
    // 작업 처리
  }
}

```
- enum 은 자바 컴파일러가 자동으로 생성자를 private 로 만들어주고, new 연산이나 리플렉션을 통한 생성도 차단해줌!
- 직렬화 문제, 리플렉션, 멀티스레드 문제까지 막을 수 있어서 가장 안전한 방법 중 하나 (Java 1.5 이상에서)

✚ 리플렉션(Reflection) 이란?
- 클래스의 구조(필드, 메서드, 생성자 등)를 런타임에 동적으로 조작할 수 있게 해주는 기능
- ex) private 생성자는 외부에서 new 로 호출할 수 없는데, 리플렉션을 쓰면 접근 제어자를 무시하고 private 생성자도 호출 가능

##### Spring
- Spring Bean 은 기본 스코프가 **싱글톤**
- @Component, @Service @Repository 등으로 등록된 클래스는 기본적으로 **싱글톤 스코프**로 관리됨
- Spring 컨테이너가 애플리케이션 실행 시 한 번만 객체를 생성하고, 필요한 곳에 동일한 인스턴스 주입
- 즉, 따로 싱글톤을 구현하지 않아도 Spring DI 만 제대로 사용하면 싱글톤 패턴처럼 동장

